using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Mvc;
using System.Diagnostics;
using System.IO;
using System.Net;
using TICS.Interfaces;
using TICS.Models.Histories;
using TICS.Tools;

namespace TICS.Models
{
    public class DirBusterModel : ComponentBase, IPentestable
    {
        [BindProperty]
        public List<DirBusterHistory> Histories { get; }
        [BindProperty]
        public string HostName { get; set; }

        [BindProperty]
        public bool Recursive { get; set; }

        [BindProperty]
        public string FileExtensions { get; set; }

        [BindProperty]
        public int Port { get; set; }

        [BindProperty]
        public int NumberOfThreads { get; set; } //Deze staat niet opgenomen in het klassendiagram

        [BindProperty]
        public string Results { get; set; }

        [BindProperty]
        public string Runtime { get; set; }

        // wordlist that is set in the code
        public List<string> wordList { get; set; }

        // required for cancelling the program
        private CancellationTokenSource _cancellationTokenSource;

        // 1 semaphore used so its not possible that 2 treads access the same file
        private static readonly SemaphoreSlim semaphoreForWriteToFile = new SemaphoreSlim(1);
        public DirBusterModel()
        {
            NumberOfThreads = 5;
            Port = 443;
            HostName = "https://demo.testfire.net";
            Histories = new List<DirBusterHistory>();
        }

        /// <summary>
        /// The Start method is binded to the frontend. Whenever the user clicks on the "scan" button, the method "Start" starts
        /// </summary>
        /// <returns></returns>
        public async Task Start()
        {
            int port = this.Port;
            string fileEx = this.FileExtensions;
            int numThread = this.NumberOfThreads;
            bool recursive = this.Recursive;

            // Create a stopwatch to measure time
            // stopwatch object
            Stopwatch stopwatch = new Stopwatch();

            stopwatch.Start();
            Runtime = "";
            Results = "Dirbuster is running....";

            Debug.WriteLine($"[*] Scanning host {this.HostName}...");

            // Valideer of er een hostname ingevuld is
            if (string.IsNullOrEmpty(HostName))
            {
                Results = "[*] Hostname is verplicht.";
                return;
            }

            // Valid of the range of ports is right
            if (Port <= 0 || Port > 65535)
            {
                Results = "[*] Ongeldige poort.";
                return;
            }

            // valid of use of mulitple threads
            if (NumberOfThreads <= 0)
            {
                Results = "[*] Ongeldig aantal threads.";
                return;
            }

            if (NumberOfThreads > 500)
            {
                Results = "[*] Nummer of threads mag niet hoger dan 500 zijn.";
                return;
            }

            // sets the wordlist retrieved from a remote github repository to an 
            if (this.setWordlist(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, $"wwwroot/dirbuster/common.txt.bk")) == false)
            {
                Results = "[*] The wordlist is not set.";
                return;
            }

            // set the hostname with the correct protocol, hostname and port
            string hostname = $"{this.HostName}:{this.Port}";

            // Create a new CancellationTokenSource
            _cancellationTokenSource = new CancellationTokenSource();

            // Create dir if nessesery
            string directory = AppDomain.CurrentDomain.BaseDirectory;
            if (!Directory.Exists(directory + "dirbuster_rapport"))
            {
                // Create the directory if it doesn't exist for rapports
                Directory.CreateDirectory(directory + "dirbuster_rapport");
                Directory.CreateDirectory(directory + "dirbuster_rapport/txt");
                Directory.CreateDirectory(directory + "dirbuster_rapport/pdf");
            }

            string filePathTxt = Path.Combine(directory, "dirbuster_rapport", "txt", $"Writeable_scanResults_{DateTime.Now:yyyyMMddHHmmss}.txt");
            string filePathPdf = Path.Combine(directory, "dirbuster_rapport", "pdf", $"Final_ScanResults_{DateTime.Now:yyyyMMddHHmmss}.pdf");

            // run dirbuster
            await this.ScanTarget(hostname, filePathTxt, filePathPdf);

            // calculate the runtime 
            TimeSpan runtime = stopwatch.Elapsed;
            string runTimeText = $"{runtime.Hours} hours {runtime.Minutes} minutes {runtime.Seconds} seconds {runtime.Milliseconds} milliseconds";
            Runtime = runTimeText;


            this.AddToHistory(new DirBusterHistory(filePathPdf, runTimeText, numThread, hostname, port, recursive, fileEx));
            // return
            return;
        }

        /// <summary>
        /// scan the specified target, based on the parameters given in, the correct path will be used
        /// </summary>
        private async Task ScanTarget(string hostname, string filePathTxt, string filePathPdf)
        {
            SemaphoreSlim semaphore = new SemaphoreSlim(this.NumberOfThreads);

            // if Recursive is selected and NO file extensions are present || if Recursive is NOT selected and NO file extensions are present
            if (string.IsNullOrEmpty(this.FileExtensions))
            {
                await SendGetRequestThreaded(hostname, this.wordList, null, _cancellationTokenSource.Token, filePathTxt, filePathPdf, semaphore, semaphoreForWriteToFile);
            }
            else
            {
                await SendGetRequestThreaded(hostname, this.wordList, new List<string>(this.FileExtensions.Split(";")),  _cancellationTokenSource.Token, filePathTxt, filePathPdf, semaphore, semaphoreForWriteToFile);
            }

           
        }

        /// <summary>
        /// Stops running threads
        /// </summary>
        public void Stop()
        {
            if (this._cancellationTokenSource != null)
            {
                this._cancellationTokenSource.Cancel();
            }

            Results = "Directory scan geannuleerd resultaten worden geladen";
        }

        /// <summary>
        /// Add histroy to list
        /// </summary>
        /// <param name="history">History object</param>
        private void AddToHistory(DirBusterHistory history)
        {
            this.Histories.Add(history);
        }

        /// <summary>
        /// send GET requests threaded
        /// </summary>
        /// <param name="urls"></param>
        /// <param name="numOfThreads"></param>
        /// <returns></returns>
        private async Task SendGetRequestThreaded(string baseUrl, List<string> urls, List<string> extensions, CancellationToken cancellationToken, string txtPath, string pdfPath, SemaphoreSlim scanningSemaphore, SemaphoreSlim fileSemaphore)
        {
            List<Task> tasks = new List<Task>();

            // Standard manner - no extensions
            foreach (string url in urls)
            {
                tasks.Add(Task.Run(async () =>
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await scanningSemaphore.WaitAsync(cancellationToken); // Wait for a slot in the semaphore, but respect the cancellation token

                    try
                    {
                        HttpResponseMessage response = await SendGetRequest(baseUrl, url, txtPath); // Await the result of SendGetRequest

                        if (response != null && response.StatusCode == HttpStatusCode.OK && this.Recursive)
                        {
                            cancellationToken.ThrowIfCancellationRequested();
                            // Create the new URL for the Recursive call
                            string RecursiveUrl = $"{baseUrl}/{url}";
                            // Call SendGetRequestThreaded Recursively with the modified Recursive url and the standard list
                            await SendGetRequestThreaded(RecursiveUrl, urls, extensions, cancellationToken, txtPath, pdfPath, scanningSemaphore, fileSemaphore);
                        }
                    }
                    catch (OperationCanceledException ex)
                    {
                        Results = "De directory is geannuleerd \\n";
                        Results += $"Gevonden resultaten zijn: {txtPath}";
                    }
                    finally
                    {
                        scanningSemaphore.Release(); // Release the slot in the semaphore
                    }
                }, cancellationToken)); // Pass the cancellation token to the Task.Run method
            }

            // If any extensions are present, apply the same logic, but then with the extensions added as well
            if (extensions != null)
            {
                foreach (string url in urls)
                {
                    foreach (string extension in extensions)
                    {
                        tasks.Add(Task.Run(async () =>
                        {
                            cancellationToken.ThrowIfCancellationRequested();
                            await scanningSemaphore.WaitAsync(cancellationToken); // Wait for a slot in the semaphore

                            try
                            {
                                await SendGetRequest(baseUrl, $"{url}.{extension}", txtPath); // Await the result of SendGetRequest
                            }
                            finally
                            {
                                scanningSemaphore.Release(); // Release the slot in the semaphore
                            }
                        }, cancellationToken));
                    }
                }
            }

            try
            {
                // Wait for all tasks to complete
                await Task.WhenAll(tasks);
                await fileSemaphore.WaitAsync(cancellationToken);
                try
                {
                    await PDFWriter.ExportTextToPdfAsync(txtPath, pdfPath);
                    Results = $"Scan results saved to text file {pdfPath}";
                }
                finally
                {
                    fileSemaphore.Release();
                }
            }
            catch (OperationCanceledException ex)
            {
                Results = "De directory is geannuleerd \\n";
                Results += $"Gevonden resultaten zijn: {txtPath}";
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred while processing tasks: {ex.Message}");
            }
        }

        /// <summary>
        /// Write to TXT file
        /// </summary>
        /// <param name="filePath"></param>
        /// <param name="text"></param>
        /// <returns>returns true when its goes right</returns>
        public async Task<bool> WriteToFile(string filePath, string text)
        {
            await semaphoreForWriteToFile.WaitAsync();

            try
            {
                using (var writer = new StreamWriter(filePath, true))
                {
                    await writer.WriteLineAsync(text);
                }
                return true;
            }
            finally
            {
                semaphoreForWriteToFile.Release();
            }
        }


        /// <summary>
        /// sends a single get request to an specific endpoint
        /// </summary>
        /// <param name="url"> URL of the GET request </param>
        /// <param name="client"> HTTP client that is used</param>
        /// <returns></returns>
        private async Task<HttpResponseMessage> SendGetRequest(string baseUrl, string path, string filePathTxt)
        {
            try
            {
                using (HttpClientHandler handler = new HttpClientHandler())
                {
                    handler.AllowAutoRedirect = false; // Disable automatic redirection
                    handler.ServerCertificateCustomValidationCallback = (sender, cert, chain, sslPolicyErrors) => true;
                    using (HttpClient client = new HttpClient(handler))
                    {
                        HttpResponseMessage response = await client.GetAsync($"{baseUrl}/{path}");

                        Debug.WriteLine($"[+] {baseUrl}/{path} - {(int)response.StatusCode}");
                        await WriteToFile(filePathTxt, $"URL {baseUrl}/{path} - Status code {(int)response.StatusCode}");

                        return response;
                    }
                }
            }
            catch (HttpRequestException ex)
            {
                await WriteToFile(filePathTxt, $"An error occurred while making the HTTP request: {ex.Message}");
                return null;
            }
            catch (Exception ex)
            {
                await WriteToFile(filePathTxt, $"An unexpected error occurred: {ex.Message}");
                return null;
            }
        }


        /// <summary>
        /// Sets the wordlist variable as a list so the words can be used from this datastructure
        /// </summary>
        /// <param name="filePath">Path of the wordlist</param>
        /// <returns></returns>
        private bool setWordlist(string filePath)
        {
            if (File.Exists(filePath))
            {
                // Read all lines from the file
                string[] lines = File.ReadAllLines(filePath);

                // Convert the array of lines to a list
                this.wordList = new List<string>(lines);
                return true;
            }

            return false;
        }
    }
}
