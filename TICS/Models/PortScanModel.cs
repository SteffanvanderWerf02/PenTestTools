using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Mvc;
using System.ComponentModel;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Text;
using TICS.Interfaces;
using TICS.Models.Histories;
using TICS.Tools;


namespace TICS.Models
{
    public class PortScanModel : ComponentBase, IPentestable
    {
        // 1 semaphore used so its not possible that 2 treads access the same file
        private static SemaphoreSlim WriterSemaphore = new SemaphoreSlim(1);

        private CancellationTokenSource _cancellationTokenSource;

        [BindProperty]
        public List<PortScanHistory> Histories { get; }

        [BindProperty]
        [DefaultValue("127.0.0.1")]
        public string TargetIp { get; set; }

        [BindProperty]
        public int StartPort { get; set; }

        [BindProperty]
        public int EndPort { get; set; }

        [BindProperty]
        [DefaultValue(1)]
        public int NumThreads { get; set; }

        [BindProperty]
        public string Protocol { get; set; }

        [BindProperty]
        public string Results { get; set; }

        [BindProperty]
        public string Runtime { get; set; }


        public PortScanModel()
        {
            NumThreads = 1;
            TargetIp = "127.0.0.1";
            EndPort = 443;
            StartPort = 0;
            Histories = new List<PortScanHistory>();
        }

        /// <summary>
        /// Start portscanning on filled in Host
        /// </summary>
        /// <returns>Returns Task</returns>
        public async Task Start()
        {
            // Valideer of er een hostname ingevuld is
            if (string.IsNullOrEmpty(TargetIp))
            {
                Results = "[*] Target is verplicht.";
                return;
            }

            // Valideer of de poort geldig is
            if (StartPort <= 0 && EndPort > 65535)
            {
                Results = "[*] Start poort man niet lager dan 0 zijn en hoogste port mag niet hoger zijn dan 65535";
                return;
            }

            Stopwatch stopwatch = new Stopwatch(); // Create a stopwatch to measure time
            stopwatch.Start(); // Start the stopwatch

            int startport = this.StartPort;
            int endport = this.EndPort;
            int numThread = this.NumThreads;
            Runtime = "";
            Results = "Portscanner is running....";

            // Initialisatie van CancellationTokenSource
            _cancellationTokenSource = new CancellationTokenSource();
            CancellationToken cancellationToken = _cancellationTokenSource.Token;

            string directory = AppDomain.CurrentDomain.BaseDirectory;

            if (!Directory.Exists(directory + "portscanner_rapport"))
            {
                // Create the directory if it doesn't exist for rapports
                Directory.CreateDirectory(directory + "portscanner_rapport");
                Directory.CreateDirectory(directory + "portscanner_rapport/txt");
                Directory.CreateDirectory(directory + "portscanner_rapport/pdf");
            }

            string filePathTxt = Path.Combine(directory, "portscanner_rapport", "txt", $"Writeable_scanResults_{DateTime.Now:yyyyMMddHHmmss}.txt");
            string filePathPdf = Path.Combine(directory, "portscanner_rapport", "pdf", $"Final_ScanResults_{DateTime.Now:yyyyMMddHHmmss}.pdf");

            try
            {
                // Check if file exists, create if not
                if (!File.Exists(filePathTxt))
                {
                    File.Create(filePathTxt).Close();
                }


                var semaphore = new SemaphoreSlim(NumThreads, NumThreads);
                var tasks = new List<Task>();
                for (int port = StartPort; port <= EndPort; port++)
                {
                    // Controleer of annulering is aangevraagd
                    cancellationToken.ThrowIfCancellationRequested();

                    await semaphore.WaitAsync(cancellationToken);

                    int capturedPort = port; // Capture the port variable

                    tasks.Add(Task.Run(async () =>
                    {
                        try
                        {
                            Debug.WriteLine($"Scanning port: {capturedPort}");
                            if (string.IsNullOrEmpty(Protocol) || Protocol == "tcp" || Protocol == "both")
                            {
                                using (var tcpClient = new TcpClient())
                                {
                                    string serviceInfo;
                                    await tcpClient.ConnectAsync(TargetIp, capturedPort);

                                    switch (capturedPort)
                                    {
                                        case 80:
                                        case 443:
                                            serviceInfo = await ServiceRecognition.GetHttpService(tcpClient);
                                            break;
                                        case 21:
                                            serviceInfo = await ServiceRecognition.GetFTPService(tcpClient);
                                            break;
                                        case 22:
                                            serviceInfo = await ServiceRecognition.GetSshServiceInfo(tcpClient);
                                            break;
                                        case 3306:
                                            serviceInfo = await ServiceRecognition.GetMySQLServerVersion(tcpClient);
                                            break;
                                        default:
                                            serviceInfo = await ServiceRecognition.GetServiceWithNmap(TargetIp, capturedPort.ToString());
                                            break;
                                    }

                                    await WriteToFile(filePathTxt, $"TCP Port {capturedPort} is open - Service: {serviceInfo}");
                                }
                            }

                            if (Protocol == "udp" || Protocol == "both")
                            {
                                using (var udpClient = new UdpClient())
                                {

                                    await udpClient.SendAsync(new byte[0], 0, new IPEndPoint(IPAddress.Parse(TargetIp), capturedPort));
                                    await udpClient.ReceiveAsync(); // This will throw if the port is closed

                                    string serviceInfo = await ServiceRecognition.GetServiceWithNmap(TargetIp, capturedPort.ToString());
                                    await WriteToFile(filePathTxt, $"UDP Port {capturedPort} is open - Service: {serviceInfo}");

                                }
                            }
                        }
                        catch (SocketException ex)
                        {
                            if (string.IsNullOrEmpty(Protocol) || Protocol == "tcp" || Protocol == "both")
                            {
                                await WriteToFile(filePathTxt, $"TCP Port {capturedPort} is closed");
                                Debug.WriteLine($"TCP Port {capturedPort} is closed");
                            }
                            if (Protocol == "udp" || Protocol == "both")
                            {
                                await WriteToFile(filePathTxt, $"UDP Port {capturedPort} is closed");

                                Debug.WriteLine($"UDP Port {capturedPort} is closed");
                            }
                        }
                        finally
                        {
                            semaphore.Release();
                        }
                    }, cancellationToken));
                }

                // Wait for all tasks to complete
                await Task.WhenAll(tasks);

                await PDFWriter.ExportTextToPdfAsync(filePathTxt, filePathPdf);

                // Calculate and format the runtime
                TimeSpan runtime = stopwatch.Elapsed;

                string runTimeText = $"{runtime.Hours} hours {runtime.Minutes} minutes {runtime.Seconds} seconds {runtime.Milliseconds} milliseconds";
                Runtime = runTimeText;

                Results = $"Scan results saved to file: {filePathPdf}";

                this.AddToHistory(new PortScanHistory(filePathPdf, runTimeText, numThread, startport, endport));
            }
            catch (OperationCanceledException ex)
            {
                Results = "Het scan procces is geannuleerd \n";
                Results += $"Gevonden resultaten zijn: {filePathTxt}";

            }
            catch (Exception ex)
            {
                Results = $"Error: {ex.Message}";
                Debug.WriteLine($"Error: {ex.Message}");
            }
        }

        /// <summary>
        /// Add histroy to list
        /// </summary>
        /// <param name="history">History object</param>
        private void AddToHistory(PortScanHistory history) {
            this.Histories.Add(history);
        }

        /// <summary>
        /// Method to stop the running threads
        /// </summary>
        public void Stop()
        {
            if (this._cancellationTokenSource != null)
            {
                this._cancellationTokenSource.Cancel();
            }
        }

        /// <summary>
        /// Write the results I/O to txt File
        /// </summary>
        /// <param name="filePath">path for writing in txt</param>
        /// <param name="text">Text to write in file</param>
        /// <returns>Returns true when writing complete</returns>
        public async Task<bool> WriteToFile(string filePath, string text)
        {

            await WriterSemaphore.WaitAsync();
            try
            {
                using (var writer = new StreamWriter(filePath, true))
                {
                    await writer.WriteLineAsync(text);
                }
                return true;
            }
            finally
            {
                WriterSemaphore.Release();
            }
        }
    }
}
